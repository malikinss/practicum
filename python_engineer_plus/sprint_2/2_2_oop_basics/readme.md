# Lesson 2.2: OOP Basics 🧱

## Description 📝

This lesson introduces **Object-Oriented Programming (OOP)** in Python, covering classes, objects, inheritance, and core OOP principles like encapsulation and polymorphism.

This lesson includes a detailed theoretical explanation, 6 programming practical tasks, and no theoretical questions, emphasizing practical OOP implementation.

## Purpose 🎯

By the end of this lesson, I will:  
✅ Understand and create classes and objects in Python  
✅ Implement inheritance and polymorphism for code reuse  
✅ Apply OOP principles to structure data and behavior  
✅ Solve practical tasks like contact management and geographic calculations

## Concepts & Theory 🔍

### 🔹 Object-Oriented Programming (OOP)

-   **Purpose**: Organize code using classes (templates) and objects (instances).
-   **Components**: Properties (data) and methods (behavior) combined in objects.
-   **Benefits**: Modularity, reusability, and clear data structure.

### 🔹 Core Concepts

-   **Class**: Blueprint defining properties and methods.
-   **Object**: Instance of a class with specific data.
-   **Constructor**: `__init__` initializes object properties.
-   **Methods**: Functions within a class (e.g., `__str__` for string representation).
-   **Interface**: Accessible properties/methods (e.g., `obj.method()`).

### 🔹 OOP Principles

-   **Inheritance**: Child classes extend parent classes, reusing or overriding behavior.
-   **Encapsulation**: Bundling data and methods, hiding implementation details.
-   **Polymorphism**: Same method name behaves differently across classes.

## Practical Task 🧪

### 1️⃣ **OOP Implementation**

The lesson includes 6 practical tasks applying OOP:

1. **`Contact` Class (2_2_1)**: Stores and displays contact info.

    - Includes `address`, `birthday`, and datetime parsing.

2. **`Contact` Update (2_2_2)**: Adds property decorators and validation.

    - Supports updating `phone` and `address` with input checks.

3. **`Contact` with `show_contact` (2_2_3)**: Replaces `print_contact`.

    - Encapsulates display logic for contact details.

4. **`Planet` Class (2_2_4)**: Models planetary properties.

    - Calculates surface area and temperature conversions.

5. **`Point`, `City`, `Mountain` Classes (2_2_5)**: Computes geographic distances.

    - Uses inheritance and haversine formula for great-circle distance.

6. **`Human` and Derived Classes (2_2_6)**: Simulates learning interactions.
    - Demonstrates inheritance and polymorphism for `Student`, `Mentor`, etc.

💡 These tasks showcase OOP in contact management, astronomy, geography, and education.

## Benefits ✅

-   OOP organizes code for scalability and reuse.
-   Inheritance and polymorphism reduce redundancy.
-   Encapsulation simplifies interaction with complex systems.
-   Practical tasks build skills for real-world applications.

## Recommendations 📌

-   Use `self` consistently for object properties/methods.
-   Implement `__str__` for readable object output.
-   Validate inputs in constructors for robust classes.
-   Leverage `super()` for proper inheritance initialization.

## Output 📜

After completing this lesson, I now:  
✅ Create and use classes/objects for structured programming  
✅ Apply inheritance and polymorphism for flexible designs  
✅ Implement OOP principles in practical scenarios  
✅ Build robust solutions for contact, planetary, and geographic tasks

## Conclusion 🚀

Mastering OOP basics empowers me to write modular, reusable Python code.  
From contact management to geographic distance calculations, I’ve developed skills to tackle diverse programming challenges using OOP principles. 🧑‍💻✨
